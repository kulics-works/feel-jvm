mod demo;

let main() Void = {

};

let a Float = 0.1 + 0.3;

let mut b Int = 321 - 300;

let c Int = 2 * 2;

let mut d Int = b + (c * 2);

let T Bool = true;

let F Bool = false;

let char Char = 'c';

let str String = "Hello, world!";

let g() Int = 1 + 2 + 3 + b;

let add(a Int, b Int) Int = a + b;

let double(x Int) Int = add(x, x) + x + 1;
/*
let blockExpr1 Int = {
    let a = 0;
    let b = 0;
    a + b
};

let blockExpr2() Int = {
    let a = 0;
    let b = 0;
    a + b
};

let blockExpr3 Void = {};

let compareExpr Void = {
    let a = 1;
    let b = 1;
    let c = a == b;
    let d = a > b;
    let e = a <> b;
    let f = a < b;
};

let logicExpr Void = {
    let a = true && true;
    let b = true || false;
};

let ifExpr1 Int = if(true) 0 else if(true) 0 else 0;

let ifExpr2 Int = if(true) { 0 } else { 1 };

let ifExpr3 Void = if(true) {} else {};

let ifStat Void = {
    if(true) {
        0;
    } else if(true) {
        1;
    } else {
        2;
    };
};

let assignment Void = {
    let mut a = 0;
    a = 1;
};

let whileStat() Void = {
    let mut i = 0;
    while (i <= 10) {
        i = i + 1;
    };
};

let localFunction() Int = {
    let f() = 123;
    let a = f();
    a
};

def Point(x Int, y Int) {
    copy() Point = Point(x, y);
    plus(other Point) Point = Point(x + other.x, y + other.y);
};
let somePoint Point = Point(1, 2);
let memberAccess(a Point, b Point) Point = Point(a.x+b.x, a.y+b.y).copy();

def Color;
def Red() Color;
def Green() Color;
def Blue() Color;

let red Color = Red();

def IntList {
    sum() Int;
};
def Nil() IntList {
    sum() Int = 0;
};
def Cons(head Int, tail IntList) IntList {
    sum() Int = 0;
};

let makeIntList() IntList = {
    let li IntList = Cons(1, Cons(2, Cons(3, Nil())));
    li.sum();
    li
};
let sumIntList(li IntList) Int = if(li is Cons v) {
    v.head + sumIntList(v.tail)
} else {
    0
};

let typePattern() Void = {
    let li IntList = Cons(1, Cons(2, Cons(3, Nil())));
    let i = if (li is Cons v) {
        v.head
    } else {
        0
    };
};

let typePattern2() Void = {
    let li IntList = Cons(1, Cons(2, Cons(3, Nil())));
    if (li is Cons v) {
        v.head;
    } else {
        0;
    };
};

let identifierPattern() Int = {
    let a = 1;
    if (a is a) 123 else 123
};

let identifierPattern2() Void = {
    let a = 1;
    if (a is a) {
        localFunction();
    } else if (a is b) {
        localFunction();
    } else {
        localFunction();
    };
};

let wildcardPattern() Int = {
    let a = 1;
    if (a is _) 123 else 123
};

let wildcardPattern2() Void = {
    let a = 1;
    if (a is _) {
        localFunction();
    } else if (a is _) {
        localFunction();
    } else {
        localFunction();
    };
};

let literalPattern() Int = {
    let a = 1;
    if (a is 1) 123 else 123
};

let literalPattern2() Void = {
    let a = 1;
    if (a is 1) {
        localFunction();
    } else if (a is 1) {
        localFunction();
    } else {
        localFunction();
    };
};

let genericsFunction[T Any](a T) T = {
    let b T = genericsFunction[T](a);
    b;
    a
};
let callGenericsFunction() Int = genericsFunction[Int](1);

def Pair[T1 Any, T2 Any](first T1, second T2);
let genericsRecord() Void = {
    let a Pair[Int, Int] = Pair[Int, Int](1, 2);
    a.first + a.second;
};

def Option[T Any];
def Some[T Any](value T) Option[T];
def None[T Any]() Option[T];

let genericsEnum() Int = {
    let x Option[Int] = Some[Int](123);
    let y Option[Int] = Some[Int](123);
    if (x is Some[Int] v) v.value else 0
};

def GenericsInterface[T1 Any, T2 Any];
def ImplementType[T Any]() GenericsInterface[T, Int];
def ImplementType2[T Any, R Any]() GenericsInterface[R, T];

let genericsSubtyping() Void = {
    let i GenericsInterface[Int, Int] = ImplementType[Int]();
    let j GenericsInterface[Int, Float] = ImplementType2[Float, Int]();
};

let genericsSubtyping2[E Any]() Void = {
    let i GenericsInterface[E, E] = ImplementType2[E, E]();
};

let array() Void = {
    let mut a = emptyArray[Int]();
    a = newArray[Int](5, 5);
    let b = a.get(2);
    a.set(2, b);
};

def I1;
def I2 {
    f() Void;
    f2(a Int) Int;
};

def C1() I2 {
    f() Void = {};
    f2(a Int) Int = a;
};

let interfaceInstance() I2 = {
    let i I2 = C1();
    let f(x I2) = 123;
    f(C1());
    C1()
};

let interfaceConstraint[T I2](v T) Void = {
    v.f();
    let x = v.f2(1);
    let i I2 = v;
};

let instanceConstraint() Void = {
    interfaceConstraint[C1](C1());
};

def Eq[T Any] {
    eq(other T) Bool;
};

def EqPair[T1 Eq[T1], T2 Eq[T2]](first T1, second T2) Eq[EqPair[T1, T2]] {
    eq(other EqPair[T1, T2]) Bool = first.eq(other.first) && second.eq(other.second);
};

def EqFoo() Eq[EqFoo] {
    eq(other EqFoo) Bool = true;
};

let complicatedGenericsType[T Eq[T]](a T, b T) Bool = {
    a.eq(b)
};

let complicatedGenericsType2() Void = {
    complicatedGenericsType[EqFoo](EqFoo(), EqFoo());
    let a = EqPair[EqFoo, EqFoo](EqFoo(), EqFoo());
    complicatedGenericsType[EqPair[EqFoo, EqFoo]](a, a);
    let b Eq[EqPair[EqFoo, EqFoo]] = a;
};
*/