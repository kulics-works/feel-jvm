mod demo;

let main() Void = {

};

let a Float = 0.1 + 0.3;

let mut b Int = 321 - 300;

let c Int = 2 * 2;

let mut d Int = b + (c * 2);

let T Bool = true;

let F Bool = false;

let g() Int = 1 + 2 + 3 + b;

let add(a Int, b Int) Int = a + b;

let double(x Int) Int = add(x, x) + x + 1;

let blockExpr1 Int = {
    let a = 0;
    let b = 0;
    a + b
};

let blockExpr2() Int = {
    let a = 0;
    let b = 0;
    a + b
};

let blockExpr3 Void = {};

let compareExpr Void = {
    let a = 1;
    let b = 1;
    let c = a == b;
    let d = a > b;
    let e = a <> b;
    let f = a < b;
};

let logicExpr Void = {
    let a = true && true;
    let b = true || false;
};

let ifExpr1 Int = if(true) 0 else if(true) 0 else 0;

let ifExpr2 Int = if(true) { 0 } else { 1 };

let ifExpr3 Void = if(true) {} else {};

let ifStat Void = {
    if(true) {
        0;
    } else if(true) {
        1;
    } else {
        2;
    };
};

let assignment Void = {
    let mut a = 0;
    a = 1;
};

let whileStat() Void = {
    let mut i = 0;
    while (i <= 10) {
        i = i + 1;
    };
};

let localFunction() Int = {
    let f() = 123;
    let a = f();
    a
};

def Point(x Int, y Int) {
    copy() Point = Point(x, y);
    plus(other Point) Point = Point(x + other.x, y + other.y);
};
let somePoint Point = Point(1, 2);
let memberAccess(a Point, b Point) Point = Point(a.x+b.x, a.y+b.y).copy();

def Color is Red() | Green() | Blue();
let red Color = Red();

def IntList is Nil() | Cons(head Int, tail IntList) {
    sum() Int = 0;
};
let makeIntList() IntList = {
    let li IntList = Cons(1, Cons(2, Cons(3, Nil())));
    li.sum();
    li
};
let sumIntList(li IntList) Int = if(li is Cons v) {
    v.head + sumIntList(v.tail)
} else {
    0
};

let typePattern() Void = {
    let li IntList = Cons(1, Cons(2, Cons(3, Nil())));
    let i = if (li is Cons v) {
        v.head
    } else {
        0
    };
};

let typePattern2() Void = {
    let li IntList = Cons(1, Cons(2, Cons(3, Nil())));
    if (li is Cons v) {
        v.head;
    } else {
        0;
    };
};

let identifierPattern() Int = {
    let a = 1;
    if (a is a) 123 else 123
};

let identifierPattern2() Void = {
    let a = 1;
    if (a is a) {
        localFunction();
    } else if (a is b) {
        localFunction();
    } else {
        localFunction();
    };
};

let wildcardPattern() Int = {
    let a = 1;
    if (a is _) 123 else 123
};

let wildcardPattern2() Void = {
    let a = 1;
    if (a is _) {
        localFunction();
    } else if (a is _) {
        localFunction();
    } else {
        localFunction();
    };
};

let literalPattern() Int = {
    let a = 1;
    if (a is 1) 123 else 123
};

let literalPattern2() Void = {
    let a = 1;
    if (a is 1) {
        localFunction();
    } else if (a is 1) {
        localFunction();
    } else {
        localFunction();
    };
};

let genericsFunction[T Any](a T) T = {
    let b T = genericsFunction[T](a);
    b;
    a
};
let callGenericsFunction() Int = genericsFunction[Int](1);

def Pair[T1 Any, T2 Any](first T1, second T2);
let genericsRecord() Void = {
    let a Pair[Int, Int] = Pair[Int, Int](1, 2);
    a.first + a.second;
};

def Option[T Any] is Some(value T) | None();
let genericsEnum() Int = {
    let x Option[Int] = Some[Int](123);
    if (x is Some[Int] v) v.value else 0
};
